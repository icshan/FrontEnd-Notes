<script>
  /**
   * 父级：Programmer 子集： FrontEnd、BackEnd
   * output: 
   * 我是一名前端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到HTML，CSS，JavaScript
   * 我是一名后端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到Node，Java，SQL。
  */
//   ;(function(_this){
//     var Buffer = function(){}
//     _this.inherit = function( Target, Origin){
//       Buffer.prototype = Origin.prototype;
//       Target.prototype = new Buffer();
//       Target.constructor = Target;
//       Target.super_class = Origin;
//     }
//   })(window);
//   function Programmer () {
    
//   }
//   Programmer.prototype = {
//     name: '程序员',
//     job : '计算机编写应用程序',
//     jobTime: 10,
//     say: function(){
//       console.log(`我是一个${this.childName}${this.name},我的工作是用${this.job},我每天工作${this.jobTime}小时，我的工作需要用到${this.skill}`)
//     }
//   }
//   function FrontEnd () {
//     this.childName = '前端';
//     this.skill = 'HTML,CSS,JavaScript';
//   }

//   function BackEnd () {
//     this.childName = '后端';
//     this.skill = 'Node，Java，SQL';
//   }

// inherit(FrontEnd, Programmer);
// inherit(BackEnd, Programmer);

// var front = new FrontEnd()
// var end = new BackEnd()
// front.say()
// end.say()

/**
 * 深拷贝(deepClone)以及浅拷贝(clone)
*/
// var OrgObj = {
//   name: 'kester',
//   age: '20',
//   sex: 'man',
//   skill: ['HTML','CSS'],
//   child: {
//     name: 'kester child',
//     age: '2',
//     sex: 'women'
//   }
// }
// // 浅拷贝
// function clone( origin, target ){
//   var target = target || {};
//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       target[key] = origin[key]
//     }
//   }
//   return target
// }

// // 深拷贝拷贝
// function deepClone( origin, target ){
//   var target = target || {},
//       toStr = Object.prototype.toString,
//       arrType = '[object Array]'

//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       if( typeof origin[key] == 'object' && origin[key] !== null){
//         toStr.call(origin[key]) === arrType ? target[key] = []
//                                             : target[key] = {}
//         deepClone(origin[key], target[key])
//       }else{
//         target[key] = origin[key]  
//       }
      
//     }
//   }
//   return target
// }


// var cloneObj = clone(OrgObj)
// var deepCloneObj = deepClone(OrgObj)
// console.log(deepCloneObj)

// cloneObj.name = 'kester is clone object'
// deepCloneObj.skill[0] = 'vidio'

// console.log(OrgObj)
// console.log(cloneObj)
// console.log(deepCloneObj)

/**
 * 封装一个myType的方法来判断类型
*/

// function myType ( origin ) {
//   var type = typeof(origin),
//       toStr = Object.prototype.toString,
//       res = {
//         '[object Array]': 'array',
//         '[object Object]': 'object',
//         '[object String]': 'object string',
//         '[object Number]': 'object number',
//         '[object Boolean]': 'object boolean'
//       };
//   if( type == null ){
//     return null
//   }else if(type == 'object'){
//     return res[toStr.call(origin)]
//   }else{
//     return type
//   }
// }
// console.log(myType({}))
/**
 * Auth: kester
 * @param {*} nums 
 * @param {*} target 
 * @return {number[]}
 */
//  var twoSum = function( nums, target ){
//   let map = {};
//   for(let i = 0; i < nums.length; i++){
//     let preIndex = target - nums[i]
//     if( map.hasOwnProperty(preIndex)){
//       return [map[preIndex],i]
//     }else{
//       map[ nums[i] ] = i
//     }
//   }
// }
// console.log(twoSum([2,5,3,1,6,7], 9)) 

// 有效的括号
/**
 * 解题思路： 将字符串中的字符依次入栈，遍历字符依次判断：
 * 1、首先判断该元素是否是 { 、 ( 、 [ ，直接入栈
 * 2、否则该字符为 } 、 ) 、 ] 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 ({， 如果继续遍历到的元素为 ), 那么当前元素序列为 ({) 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 false ，字符串无效
 *   当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效
*/
// var isValid = function ( s ) {
//   let str = s || '',
//       stack = [],
//       resMap = {
//         '{': '}',
//         '[': ']',
//         '(': ')'
//       };
//   for(let i = 0; i <= str.length; i++){
//     let strVal = str[i],
//         resMapVal = resMap[strVal];
//     if(resMapVal){
//       stack.push(strVal)
//     }else if( strVal !== resMap[ stack.pop() ] ){
//       return false
//     }
//   }
//   return stack.length == 0
// }
// console.log(isValid('{{[()]}}'))
// console.log(isValid('({)'))

// var Quick = function ( origin ) {
//   if( origin.length <= 1) return origin
//   let target = [],
//       midIndex = Math.floor( origin.length / 2 ),
//       mid = origin.splice(midIndex, 1)[0],
//       leftArr = [],
//       rightArr = [];
//   for( let i = 0; i < origin.length; i++){
//     origin[i] < mid ? leftArr.push( origin[i] )
//                     : rightArr.push( origin[i] );
//   }
//   target = Quick(leftArr).concat(mid, Quick(rightArr));
//   return target
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Quick(arr))

// var Insert = function ( origin ) {
//   let target = [];
//   // 随机放入一张牌，这里默认第一张
//   target.push( origin[0] );
//   // 从第二张开始遍历
//   for( let i = 1; i < origin.length; i++){
//     // 遍历手中的牌，进行作比较
//     for( let j = target.length; j >= 0; j-- ){
//       if( target[j] < origin[i] ){
//         target.splice(j+1, 0, origin[i]);
//         break;
//       }
//       j == 0 && target.unshift(origin[i])
//     }
//   }

//   return target
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Insert(arr))

// var Bubble = function ( origin ) {
//   // 对比的次数为length-1次，因为只需要将length-1个数排在数组的后面就行了
//   for( let i = 0; i < origin.length-1; i++){
//     // 控制每一轮比较的次数
//     for( let j = 0; j < origin,length - i - 1; j++){
//       if( origin[j] > origin[j+1] ){
//         [ origin[j], origin[j+1] ] = [ origin[j+1], origin[j] ]
//       }
//     }

//   }
//   return origin
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Bubble(arr))

// var LongString = function ( string ) {
//   let slideArr = [],
//       maxLength =0;
//   for( let i = 0; i < string.length; i++){
//     let currVal = string[i]; 
//     // 这种方式有兼容问题
//     // let currVal = string.chatAt(i),
//         slideIndex = slideArr.indexOf(currVal);
//     if( slideIndex !== -1 ){
//       maxLength = slideArr.length;
//       slideArr.splice(0, slideIndex + 1);
//     }
//     slideArr.push(currVal);
//   }
//   return maxLength
// }

// // TEST 
// var test = 'abcabcabcd';
// console.log(LongString(test))


// var threeSum = function (origin) {
//     const result = [];
//     // 数组排序
//     const uniqueArr = Unique(origin);
//     for( let i = 0; i < uniqueArr.length - 2; i++){
//       if( i === 0 || uniqueArr[i] !== uniqueArr[i-1]){
//         // 定义双指针 start end 往中间收缩
//         let start = i + 1,end = uniqueArr.length - 1;
//         while(start < end){
//           if(uniqueArr[start] + uniqueArr[end] + uniqueArr[i] === 0){
//             result.push([uniqueArr[i], uniqueArr[start], uniqueArr[end]]);
//             start++;
//             end--;
//             while(start < end &&  uniqueArr[start] === nums[start - 1]){
//               start++;
//             }
//             while(start < end && uniqueArr[end] === uniqueArr[end+1]){
//               end--;
//             }
//           }else if(uniqueArr[start] + uniqueArr[end] + uniqueArr[i] < 0){
//             start++;
//           }else{
//             end--;
//           }
//         }
//       }
      
//     }
//     return result
// }
// console.log(threeSum([1,-1,0,1,-1,2]))
// threeSum([1,-1,0,1,-1,2])
// function trap(height = []){
//   // 1.处理边界问题
//   if(height.length === 0){
//     return 0;
//   }
//   const n = height.length;
//   let res = 0;
//   // 2.遍历数组，取出每个位置i的装水量，相加得出最后的结果
//   for(let i = 1; i < n-1; i++){
//     let l_max = 0;
//     let r_max = 0;
//     // 3.获取右边最高的柱子
//     for(let j = i; j < n; j++){
//       r_max = Math.max(r_max, height[j]);
//     }
//     // 3.获取右边最高的柱子
//     for(let j = i; j >= 0; j--){
//       l_max = Math.max(l_max, height[j]);
//     }
//     res += Math.min(r_max, l_max) - height[i]
//   }
//   return res
// }
// function trap(height = []){
//   // 1.处理边界问题
//   if(height.length === 0){
//     return 0;
//   }
//   const n = height.length;
//   let res = 0;
  
//   // 2.定义两个数组，记录l_max[i]以及r_max[i](其实就是动态规划中的memo)
//   let l_max = new Array(n);
//   let r_max = new Array(n);

//   l_max[0] = height[0];
//   r_max[n-1] = height[n-1];

//   // 3.计算l_max，从左到右
//   for(let i = 1; i < n; i++){
//     l_max[i] = Math.max(height[i], l_max[i-1]);
//   }
//   // 4.计算r_max，从右到左
//   for(let i = n-2; i >= 0; i--){
//     r_max[i] = Math.max(height[i], r_max[i+1]);
//   }
//   // 5.计算所有位置i的装水量之和
//   for(let i = 1; i < n-1; i++){
//     res += Math.min(l_max[i], r_max[i]) - height[i];
//   }
//   return res
// }
// function trap(height = []){
//   // 1.处理边界问题
//   if(height.length === 0){
//     return 0;
//   }
//   const n = height.length;
//   let res = 0;
//   // 2.定义两个指针 left、right
//   let left = 0;
//   let right = n - 1;
//   // 3.初始化l_max和r_max
//   let l_max = height[0];
//   let r_max = height[n - 1];
//   // 4.双指正left和right，依次向中间移动
//   while(left <= right){
//     l_max = Math.max(l_max, height[left]);
//     r_max = Math.max(r_max, height[right]);
  
//     if(l_max < r_max){
//       res += l_max - height[left];
//       left++;
//     }else{
//       res += r_max - height[right];
//       right--;
//     }
//   }
//   return res
// }
// class XhrHook {
//   constructor(beforeHooks = {}, afterHooks = {}){
//     this.xhr = window.XMLHttpRequest;
//     this.beforeHooks = beforeHooks;
//     this.afterHooks = afterHooks;
//     this.init();
//   }

//   init(){
//     let _this = this
//     window.XMLHttpRequest = function(){
//       this._xhr = new _this.xhr();
//     }
//   }

// }

// 原地建堆
//  节点 i 父节点 i/2  左子 2i  右子 2i+1
// function buildHeap(items, heapSize) {
//   while(heapSize < items.length - 1) {
//       heapSize ++
//       heapify(items, heapSize)
//   }
// }

// function heapify(items, i) {
//   console.log(i)
//   // 自下而上式堆化
//   while (Math.floor(i/2) > 0 && items[i] < items[Math.floor(i/2)]) {  
//       swap(items, i, Math.floor(i/2)); // 交换 
//       i = Math.floor(i/2); 
//   }
// }  

// function swap(items, i, j) {
//   let temp = items[i]
//   items[i] = items[j]
//   items[j] = temp
// }

// // 测试
// var items = [,3,2,3,1,2,4,5,5,6]
// // 初始有效序列长度为 1
// buildHeap(items, 1)
// console.log(items)
// // [empty, 1, 2, 3, 5, 4]

function buildHeap(items, heapSize){
  for(let i = Math.floor(heapSize/2); i >= 1; --i){
    heapify(items, heapSize, i);
  }
}
// 自上而下式堆化
function heapify(items, heapSize, i){
  while(true){
    let minIndex = i;
    if(i*2 <= heapSize && items[2*i] < items[i]){
      minIndex = 2*i
    }
    if(i*2+1 <= heapSize && items[2*i+1] < items[minIndex]){
      minIndex = 2*i+1
    }
    if(minIndex === i) break;
    swap(items, i, minIndex);
    i = minIndex;
  }
}
// 交换
function swap(items, i, minIndex){
  let temp = items[i];
  items[i] = items[minIndex];
  items[minIndex]=  temp
}
let arr = [,5,2,3,4,1]
buildHeap(arr, arr.length-1)
console.log(arr)
</script>