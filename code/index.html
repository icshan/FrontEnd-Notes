<script>
  /**
   * 父级：Programmer 子集： FrontEnd、BackEnd
   * output: 
   * 我是一名前端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到HTML，CSS，JavaScript
   * 我是一名后端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到Node，Java，SQL。
  */
//   ;(function(_this){
//     var Buffer = function(){}
//     _this.inherit = function( Target, Origin){
//       Buffer.prototype = Origin.prototype;
//       Target.prototype = new Buffer();
//       Target.constructor = Target;
//       Target.super_class = Origin;
//     }
//   })(window);
//   function Programmer () {
    
//   }
//   Programmer.prototype = {
//     name: '程序员',
//     job : '计算机编写应用程序',
//     jobTime: 10,
//     say: function(){
//       console.log(`我是一个${this.childName}${this.name},我的工作是用${this.job},我每天工作${this.jobTime}小时，我的工作需要用到${this.skill}`)
//     }
//   }
//   function FrontEnd () {
//     this.childName = '前端';
//     this.skill = 'HTML,CSS,JavaScript';
//   }

//   function BackEnd () {
//     this.childName = '后端';
//     this.skill = 'Node，Java，SQL';
//   }

// inherit(FrontEnd, Programmer);
// inherit(BackEnd, Programmer);

// var front = new FrontEnd()
// var end = new BackEnd()
// front.say()
// end.say()

/**
 * 深拷贝(deepClone)以及浅拷贝(clone)
*/
// var OrgObj = {
//   name: 'kester',
//   age: '20',
//   sex: 'man',
//   skill: ['HTML','CSS'],
//   child: {
//     name: 'kester child',
//     age: '2',
//     sex: 'women'
//   }
// }
// // 浅拷贝
// function clone( origin, target ){
//   var target = target || {};
//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       target[key] = origin[key]
//     }
//   }
//   return target
// }

// // 深拷贝拷贝
// function deepClone( origin, target ){
//   var target = target || {},
//       toStr = Object.prototype.toString,
//       arrType = '[object Array]'

//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       if( typeof origin[key] == 'object' && origin[key] !== null){
//         toStr.call(origin[key]) === arrType ? target[key] = []
//                                             : target[key] = {}
//         deepClone(origin[key], target[key])
//       }else{
//         target[key] = origin[key]  
//       }
      
//     }
//   }
//   return target
// }


// var cloneObj = clone(OrgObj)
// var deepCloneObj = deepClone(OrgObj)
// console.log(deepCloneObj)

// cloneObj.name = 'kester is clone object'
// deepCloneObj.skill[0] = 'vidio'

// console.log(OrgObj)
// console.log(cloneObj)
// console.log(deepCloneObj)

/**
 * 封装一个myType的方法来判断类型
*/

// function myType ( origin ) {
//   var type = typeof(origin),
//       toStr = Object.prototype.toString,
//       res = {
//         '[object Array]': 'array',
//         '[object Object]': 'object',
//         '[object String]': 'object string',
//         '[object Number]': 'object number',
//         '[object Boolean]': 'object boolean'
//       };
//   if( type == null ){
//     return null
//   }else if(type == 'object'){
//     return res[toStr.call(origin)]
//   }else{
//     return type
//   }
// }
// console.log(myType({}))
/**
 * Auth: kester
 * @param {*} nums 
 * @param {*} target 
 * @return {number[]}
 */
//  var twoSum = function( nums, target ){
//   let map = {};
//   for(let i = 0; i < nums.length; i++){
//     let preIndex = target - nums[i]
//     if( map.hasOwnProperty(preIndex)){
//       return [map[preIndex],i]
//     }else{
//       map[ nums[i] ] = i
//     }
//   }
// }
// console.log(twoSum([2,5,3,1,6,7], 9)) 

// 有效的括号
/**
 * 解题思路： 将字符串中的字符依次入栈，遍历字符依次判断：
 * 1、首先判断该元素是否是 { 、 ( 、 [ ，直接入栈
 * 2、否则该字符为 } 、 ) 、 ] 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 ({， 如果继续遍历到的元素为 ), 那么当前元素序列为 ({) 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 false ，字符串无效
 *   当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效
*/
// var isValid = function ( s ) {
//   let str = s || '',
//       stack = [],
//       resMap = {
//         '{': '}',
//         '[': ']',
//         '(': ')'
//       };
//   for(let i = 0; i <= str.length; i++){
//     let strVal = str[i],
//         resMapVal = resMap[strVal];
//     if(resMapVal){
//       stack.push(strVal)
//     }else if( strVal !== resMap[ stack.pop() ] ){
//       return false
//     }
//   }
//   return stack.length == 0
// }
// console.log(isValid('{{[()]}}'))
// console.log(isValid('({)'))

var Quick = function ( origin ) {
  if( origin.length <= 1) return origin
  let target = [],
      midIndex = Math.floor( origin.length / 2 ),
      mid = origin.splice(midIndex, 1)[0],
      leftArr = [],
      rightArr = [];
  for( let i = 0; i < origin.length; i++){
    origin[i] < mid ? leftArr.push( origin[i] )
                    : rightArr.push( origin[i] );
  }
  target = Quick(leftArr).concat(mid, Quick(rightArr));
  return target
}
// TEST
var arr = [2, 3, 45, 66, 78, 33];
console.log(Quick(arr))

</script>