<script>
  /**
   * 父级：Programmer 子集： FrontEnd、BackEnd
   * output: 
   * 我是一名前端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到HTML，CSS，JavaScript
   * 我是一名后端程序员，我的工作是用计算机编写应用程序，我每天工作10小时，我的工作需要用到Node，Java，SQL。
  */
//   ;(function(_this){
//     var Buffer = function(){}
//     _this.inherit = function( Target, Origin){
//       Buffer.prototype = Origin.prototype;
//       Target.prototype = new Buffer();
//       Target.constructor = Target;
//       Target.super_class = Origin;
//     }
//   })(window);
//   function Programmer () {
    
//   }
//   Programmer.prototype = {
//     name: '程序员',
//     job : '计算机编写应用程序',
//     jobTime: 10,
//     say: function(){
//       console.log(`我是一个${this.childName}${this.name},我的工作是用${this.job},我每天工作${this.jobTime}小时，我的工作需要用到${this.skill}`)
//     }
//   }
//   function FrontEnd () {
//     this.childName = '前端';
//     this.skill = 'HTML,CSS,JavaScript';
//   }

//   function BackEnd () {
//     this.childName = '后端';
//     this.skill = 'Node，Java，SQL';
//   }

// inherit(FrontEnd, Programmer);
// inherit(BackEnd, Programmer);

// var front = new FrontEnd()
// var end = new BackEnd()
// front.say()
// end.say()

/**
 * 深拷贝(deepClone)以及浅拷贝(clone)
*/
// var OrgObj = {
//   name: 'kester',
//   age: '20',
//   sex: 'man',
//   skill: ['HTML','CSS'],
//   child: {
//     name: 'kester child',
//     age: '2',
//     sex: 'women'
//   }
// }
// // 浅拷贝
// function clone( origin, target ){
//   var target = target || {};
//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       target[key] = origin[key]
//     }
//   }
//   return target
// }

// // 深拷贝拷贝
// function deepClone( origin, target ){
//   var target = target || {},
//       toStr = Object.prototype.toString,
//       arrType = '[object Array]'

//   for( var key in origin ){
//     if( origin.hasOwnProperty(key) ){
//       if( typeof origin[key] == 'object' && origin[key] !== null){
//         toStr.call(origin[key]) === arrType ? target[key] = []
//                                             : target[key] = {}
//         deepClone(origin[key], target[key])
//       }else{
//         target[key] = origin[key]  
//       }
      
//     }
//   }
//   return target
// }


// var cloneObj = clone(OrgObj)
// var deepCloneObj = deepClone(OrgObj)
// console.log(deepCloneObj)

// cloneObj.name = 'kester is clone object'
// deepCloneObj.skill[0] = 'vidio'

// console.log(OrgObj)
// console.log(cloneObj)
// console.log(deepCloneObj)

/**
 * 封装一个myType的方法来判断类型
*/

// function myType ( origin ) {
//   var type = typeof(origin),
//       toStr = Object.prototype.toString,
//       res = {
//         '[object Array]': 'array',
//         '[object Object]': 'object',
//         '[object String]': 'object string',
//         '[object Number]': 'object number',
//         '[object Boolean]': 'object boolean'
//       };
//   if( type == null ){
//     return null
//   }else if(type == 'object'){
//     return res[toStr.call(origin)]
//   }else{
//     return type
//   }
// }
// console.log(myType({}))
/**
 * Auth: kester
 * @param {*} nums 
 * @param {*} target 
 * @return {number[]}
 */
//  var twoSum = function( nums, target ){
//   let map = {};
//   for(let i = 0; i < nums.length; i++){
//     let preIndex = target - nums[i]
//     if( map.hasOwnProperty(preIndex)){
//       return [map[preIndex],i]
//     }else{
//       map[ nums[i] ] = i
//     }
//   }
// }
// console.log(twoSum([2,5,3,1,6,7], 9)) 

// 有效的括号
/**
 * 解题思路： 将字符串中的字符依次入栈，遍历字符依次判断：
 * 1、首先判断该元素是否是 { 、 ( 、 [ ，直接入栈
 * 2、否则该字符为 } 、 ) 、 ] 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 ({， 如果继续遍历到的元素为 ), 那么当前元素序列为 ({) 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 false ，字符串无效
 *   当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效
*/
// var isValid = function ( s ) {
//   let str = s || '',
//       stack = [],
//       resMap = {
//         '{': '}',
//         '[': ']',
//         '(': ')'
//       };
//   for(let i = 0; i <= str.length; i++){
//     let strVal = str[i],
//         resMapVal = resMap[strVal];
//     if(resMapVal){
//       stack.push(strVal)
//     }else if( strVal !== resMap[ stack.pop() ] ){
//       return false
//     }
//   }
//   return stack.length == 0
// }
// console.log(isValid('{{[()]}}'))
// console.log(isValid('({)'))

// var Quick = function ( origin ) {
//   if( origin.length <= 1) return origin
//   let target = [],
//       midIndex = Math.floor( origin.length / 2 ),
//       mid = origin.splice(midIndex, 1)[0],
//       leftArr = [],
//       rightArr = [];
//   for( let i = 0; i < origin.length; i++){
//     origin[i] < mid ? leftArr.push( origin[i] )
//                     : rightArr.push( origin[i] );
//   }
//   target = Quick(leftArr).concat(mid, Quick(rightArr));
//   return target
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Quick(arr))

// var Insert = function ( origin ) {
//   let target = [];
//   // 随机放入一张牌，这里默认第一张
//   target.push( origin[0] );
//   // 从第二张开始遍历
//   for( let i = 1; i < origin.length; i++){
//     // 遍历手中的牌，进行作比较
//     for( let j = target.length; j >= 0; j-- ){
//       if( target[j] < origin[i] ){
//         target.splice(j+1, 0, origin[i]);
//         break;
//       }
//       j == 0 && target.unshift(origin[i])
//     }
//   }

//   return target
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Insert(arr))

// var Bubble = function ( origin ) {
//   // 对比的次数为length-1次，因为只需要将length-1个数排在数组的后面就行了
//   for( let i = 0; i < origin.length-1; i++){
//     // 控制每一轮比较的次数
//     for( let j = 0; j < origin,length - i - 1; j++){
//       if( origin[j] > origin[j+1] ){
//         [ origin[j], origin[j+1] ] = [ origin[j+1], origin[j] ]
//       }
//     }

//   }
//   return origin
// }
// // TEST
// var arr = [2, 3, 45, 66, 78, 33];
// console.log(Bubble(arr))

// var LongString = function ( string ) {
//   let slideArr = [],
//       maxLength =0;
//   for( let i = 0; i < string.length; i++){
//     let currVal = string[i]; 
//     // 这种方式有兼容问题
//     // let currVal = string.chatAt(i),
//         slideIndex = slideArr.indexOf(currVal);
//     if( slideIndex !== -1 ){
//       maxLength = slideArr.length;
//       slideArr.splice(0, slideIndex + 1);
//     }
//     slideArr.push(currVal);
//   }
//   return maxLength
// }

// // TEST 
// var test = 'abcabcabcd';
// console.log(LongString(test))


// var threeSum = function (origin) {
//     const result = [];
//     // 数组排序
//     const uniqueArr = Unique(origin);
//     for( let i = 0; i < uniqueArr.length - 2; i++){
//       if( i === 0 || uniqueArr[i] !== uniqueArr[i-1]){
//         // 定义双指针 start end 往中间收缩
//         let start = i + 1,end = uniqueArr.length - 1;
//         while(start < end){
//           if(uniqueArr[start] + uniqueArr[end] + uniqueArr[i] === 0){
//             result.push([uniqueArr[i], uniqueArr[start], uniqueArr[end]]);
//             start++;
//             end--;
//             while(start < end &&  uniqueArr[start] === nums[start - 1]){
//               start++;
//             }
//             while(start < end && uniqueArr[end] === uniqueArr[end+1]){
//               end--;
//             }
//           }else if(uniqueArr[start] + uniqueArr[end] + uniqueArr[i] < 0){
//             start++;
//           }else{
//             end--;
//           }
//         }
//       }
      
//     }
//     return result
// }
// console.log(threeSum([1,-1,0,1,-1,2]))
// threeSum([1,-1,0,1,-1,2])
</script>